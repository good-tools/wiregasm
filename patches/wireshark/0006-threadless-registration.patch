From 7d6afee5ca02173a02557275b0e5657485338fa5 Mon Sep 17 00:00:00 2001
From: Osama Khalid <osama@codinghazard.com>
Date: Sat, 22 Jun 2024 15:43:27 -0400
Subject: [PATCH] synchronous registration

---
 epan/register.c | 111 +++++++++---------------------------------------
 1 file changed, 21 insertions(+), 90 deletions(-)

diff --git a/epan/register.c b/epan/register.c
index 1f8f2c2fa5..e8377d5913 100644
--- a/epan/register.c
+++ b/epan/register.c
@@ -17,70 +17,28 @@
 
 #include "epan/dissectors/dissectors.h"
 
-static const char *cur_cb_name = NULL;
-// We could use g_atomic_pointer_set/get instead of a mutex, but that causes
-// a false positive with Clang and TSAN for GLib < 2.64.0 (Issue #17753):
-// https://gitlab.gnome.org/GNOME/glib/-/issues/1843
-static GMutex cur_cb_name_mtx;
-static GAsyncQueue *register_cb_done_q;
-
-#define CB_WAIT_TIME (150 * 1000) // microseconds
-
-static void set_cb_name(const char *proto) {
-    g_mutex_lock(&cur_cb_name_mtx);
-    cur_cb_name = proto;
-    g_mutex_unlock(&cur_cb_name_mtx);
-}
-
-static void *
-register_all_protocols_worker(void *arg _U_)
+void
+register_all_protocols(register_cb cb, gpointer cb_data)
 {
-    void *volatile error_message = NULL;
+    const char *cb_name = NULL;
+    gboolean called_back = FALSE;
+    const char *error_message = NULL;
 
     TRY {
         for (gulong i = 0; i < dissector_reg_proto_count; i++) {
-            set_cb_name(dissector_reg_proto[i].cb_name);
+            cb_name = dissector_reg_proto[i].cb_name;
             dissector_reg_proto[i].cb_func();
+            if (cb && cb_name) {
+                cb(RA_REGISTER, cb_name, cb_data);
+                called_back = TRUE;
+            }
         }
     }
     CATCH(DissectorError) {
-        /*
-         * This is probably a dissector, or something it calls,
-         * calling REPORT_DISSECTOR_ERROR() in a registration
-         * routine or something else outside the normal dissection
-         * code path.
-         *
-         * The message gets freed by ENDTRY, so we must make a copy
-         * of it.
-         */
         error_message = g_strdup(GET_MESSAGE);
     }
     ENDTRY;
 
-    g_async_queue_push(register_cb_done_q, GINT_TO_POINTER(TRUE));
-    return (void *) error_message;
-}
-
-void
-register_all_protocols(register_cb cb, gpointer cb_data)
-{
-    const char *cb_name;
-    register_cb_done_q = g_async_queue_new();
-    gboolean called_back = FALSE;
-    GThread *rapw_thread;
-    const char *error_message;
-
-    rapw_thread = g_thread_new("register_all_protocols_worker", &register_all_protocols_worker, NULL);
-    while (!g_async_queue_timeout_pop(register_cb_done_q, CB_WAIT_TIME)) {
-        g_mutex_lock(&cur_cb_name_mtx);
-        cb_name = cur_cb_name;
-        g_mutex_unlock(&cur_cb_name_mtx);
-        if (cb && cb_name) {
-            cb(RA_REGISTER, cb_name, cb_data);
-            called_back = TRUE;
-        }
-    }
-    error_message = (const char *) g_thread_join(rapw_thread);
     if (error_message != NULL)
         THROW_MESSAGE(DissectorError, error_message);
     if (cb && !called_back) {
@@ -88,61 +46,34 @@ register_all_protocols(register_cb cb, gpointer cb_data)
     }
 }
 
-static void *
-register_all_protocol_handoffs_worker(void *arg _U_)
+void
+register_all_protocol_handoffs(register_cb cb, gpointer cb_data)
 {
-    void *volatile error_message = NULL;
+    const char *cb_name = NULL;
+    gboolean called_back = FALSE;
+    const char *error_message = NULL;
 
     TRY {
         for (gulong i = 0; i < dissector_reg_handoff_count; i++) {
-            set_cb_name(dissector_reg_handoff[i].cb_name);
+            cb_name = dissector_reg_handoff[i].cb_name;
             dissector_reg_handoff[i].cb_func();
+
+            if (cb && cb_name) {
+                cb(RA_HANDOFF, cb_name, cb_data);
+                called_back = TRUE;
+            }
         }
     }
     CATCH(DissectorError) {
-        /*
-         * This is probably a dissector, or something it calls,
-         * calling REPORT_DISSECTOR_ERROR() in a registration
-         * routine or something else outside the normal dissection
-         * code path.
-         *
-         * The message gets freed by ENDTRY, so we must make a copy
-         * of it.
-         */
         error_message = g_strdup(GET_MESSAGE);
     }
     ENDTRY;
 
-    g_async_queue_push(register_cb_done_q, GINT_TO_POINTER(TRUE));
-    return (void *) error_message;
-}
-
-void
-register_all_protocol_handoffs(register_cb cb, gpointer cb_data)
-{
-    const char *cb_name;
-    gboolean called_back = FALSE;
-    GThread *raphw_thread;
-    const char *error_message;
-
-    set_cb_name(NULL);
-    raphw_thread = g_thread_new("register_all_protocol_handoffs_worker", &register_all_protocol_handoffs_worker, NULL);
-    while (!g_async_queue_timeout_pop(register_cb_done_q, CB_WAIT_TIME)) {
-        g_mutex_lock(&cur_cb_name_mtx);
-        cb_name = cur_cb_name;
-        g_mutex_unlock(&cur_cb_name_mtx);
-        if (cb && cb_name) {
-            cb(RA_HANDOFF, cb_name, cb_data);
-            called_back = TRUE;
-        }
-    }
-    error_message = (const char *) g_thread_join(raphw_thread);
     if (error_message != NULL)
         THROW_MESSAGE(DissectorError, error_message);
     if (cb && !called_back) {
         cb(RA_HANDOFF, "finished", cb_data);
     }
-    g_async_queue_unref(register_cb_done_q);
 }
 
 gulong register_count(void)
-- 
2.43.0

